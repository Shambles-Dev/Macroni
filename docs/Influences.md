Influences
==========

I want to give credit where credit is due.

<table>
  <tr>
    <th>Influences</th>
    <th>Macroni Features</th>
  </tr>
  <tr>
    <td><p><a href="http://www.smalltalk.org/">Smalltalk</a> programming language</p></td>
    <td><p>operating system (that can also run as a process) with an integrated development environment; automated refactoring; self-building</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://en.wikipedia.org/wiki/Desktop_search">desktop search</a> software</p>
      <p><a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> query language</p>
      <p><a href="https://openzfs.org/wiki/Main_Page">OpenZFS</a> file system</p>
      <p><a href="https://btrfs.readthedocs.io/en/latest/">Btrfs</a> file system</p>
      <p><a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html?highlight=overlayfs">OverlayFS</a> file system</p>
    </td>
    <td><p>database file system</p></td>
  </tr>
  <tr>
    <td><p><a href="https://semver.org/">Semantic Versioning</a> versioning scheme</p></td>
    <td><p>Simplified Semantic Versioning</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.erlang.org/">Erlang</a> programming language</p></td>
    <td><p>threads with separate heaps; microrebooting for handling updates and defects</p></td>
  </tr>
  <tr>
    <td><p><a href="https://en.wikipedia.org/wiki/Multics">Multics</a> operating system</p></td>
    <td><p>transparent persistence (but Macroni’s is hard-state-reimport-based)</p></td>
  </tr>
  <tr>
    <td><p><a href="http://www.erights.org/">E</a> programming language</p></td>
    <td><p>object capabilities</p></td>
  </tr>
  <tr>
    <td><p><a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.9948">PDP-1 Supervisor</a> operating system</p></td>
    <td><p>C-list capabilities</p></td>
  </tr>
  <tr>
    <td><p><a href="https://frogatto.com/2012/05/25/a-gentle-introduction-to-frogatto-formula-language/">Frogatto Formula Language</a> programming language</p></td>
    <td><p>side effects as values</p></td>
  </tr>
  <tr>
    <td><p><a href="https://genode.org/">Genode</a> operating system</p></td>
    <td><p>sandboxes (PD sessions in Genode); modules (executable ROM modules in Genode)</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://en.wikipedia.org/wiki/NeWS">NeWS</a> desktop</p>
      <p><a href="https://en.wikipedia.org/wiki/NeXTstep">NeXTstep</a> desktop</p>
      <p><a href="https://en.wikipedia.org/wiki/DragThing">DragThing</a> dock and shelf</p>
      <p><a href="http://www.combex.com/tech/edesk.html">CapDesk</a> desktop</p>
    </td>
    <td>
      <p>vector-graphics-based user interface</p>
      <p>chiseled widgets</p>
      <p>dock; shelf</p>
      <p>secure user interaction</p>
    </td>
  </tr>
  <tr>
    <td>
      <p><a href="https://interlisp.org/">Interlisp</a>’s <a href="https://www.youtube.com/watch?v=2qsmF8HHskg">SEdit</a> editor</p>
      <p><a href="https://www.gnu.org/software/emacs/">Emacs</a> editor with <a href="https://www.emacswiki.org/emacs/ParEdit">Paredit</a>, <a href="https://www.emacswiki.org/emacs/HighlightSexps">Highlight Sexps</a>, and <a href="https://common-lisp.net/project/slime/">SLIME</a> plug-ins</p>
    </td>
    <td><p>structure editing; code searching; code cross-referencing</p></td>
  </tr>
  <tr>
    <td><p><a href="https://common-lisp.net/">Common Lisp</a> programming language</p></td>
    <td><p>docstrings; listeners; generic functions; defined mechanism and left to right order of evaluation of all non-macro arguments</p></td>
  </tr>
  <tr>
    <td><p><a href="https://github.com/jcoglan/heist">Heist</a> programming language</p></td>
    <td><p>listener transcripts that require minimal editing to use as source code</p></td>
  </tr>
  <tr>
    <td><p><a href="https://plse.cs.washington.edu/daikon/">Daikon</a> invariant detector</p></td>
    <td><p>invariant detector</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a> library</p></td>
    <td><p>property-based testing</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.rand.org/pubs/research_memoranda/RM5772.html">EXDAMS</a> debugger</p></td>
    <td><p>post-mortem replay debugger</p></td>
  </tr>
  <tr>
    <td><p><a href="http://weitz.de/regex-coach/">The Regex Coach</a> regular expression debugger</p></td>
    <td><p>regular expression debugger</p></td>
  </tr>
  <tr>
    <td><p><a href="https://en.wikipedia.org/wiki/Interface_Builder">Interface Builder</a> GUI builder</p></td>
    <td><p>GUI builder</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.perl.org/">Perl</a> programming language</p></td>
    <td><p>taint checking (but Macroni’s is more powerful)</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.call-cc.org/">CHICKEN</a> programming language</p></td>
    <td><p>implicit renaming macro system (but Macroni’s is less powerful and more secure and optimizable)</p></td>
  </tr>
  <tr>
    <td><p><a href="https://clojure.org/">Clojure</a> programming language</p></td>
    <td><p>immutable vectors, sets, and dictionaries; random access data structures as functions; dictionaries as sequences of vectors containing key-value pairs</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://en.wikipedia.org/wiki/SETL">SETL</a> programming language</p>
      <p><a href="https://racket-lang.org/">Racket</a> programming language</p>
    </td>
    <td><p>vector, set, and dictionary comprehensions</p></td>
  </tr>
  <tr>
    <td><p><a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML</a> programming language</p></td>
    <td><p>option types (a.k.a. nullable types)</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.python.org/">Python</a> programming language</p></td>
    <td><p>no global scope; Boolean coercion rules (but Macroni’s Boolean special forms always return a Boolean value); sets and dictionaries that are insertion order preserving and order insignificant</p></td>
  </tr>
  <tr>
    <td><p><a href="https://www.schemers.org/">Scheme</a> programming language</p></td>
    <td><p>same namespace for variables and procedures; numeric tower (but Macroni’s includes Booleans as a subtype of integers (influenced by Python)); Scheme streams; tail call elimination; defined mechanism and left to right order of evaluation of the functional position</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/">C#</a> programming language</p>
      <p><a href="https://www.ruby-lang.org/en/">Ruby</a> programming language</p>
    </td>
    <td><p>extension generic functions (analogous to extension methods in C# and refinements in Ruby)</p></td>
  </tr>
  <tr>
    <td><p><a href="https://dlang.org/">D</a> programming language</p></td>
    <td><p>uniform function call syntax (but Macroni’s dispatch argument is the first rest argument or the last argument if there is no rest parameter, and procedure lookup is lexical)</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://www.eiffel.org/">Eiffel</a> programming language</p>
      <p><a href="https://racket-lang.org/">Racket</a> programming language</p>
    </td>
    <td><p>design by contract</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://www.gnu.org/software/kawa/">Kawa</a> programming language</p>
      <p><a href="https://frinklang.org/">Frink</a> programming language</p>
      <p><a href="https://fsharp.org/">F#</a> programming language</p>
    </td>
    <td><p>dimensional analysis</p></td>
  </tr>
  <tr>
    <td><p><a href="https://scsh.net/">Scsh</a> programming language</p></td>
    <td><p>SREs</p></td>
  </tr>
  <tr>
    <td>
      <p><a href="https://www.swi-prolog.org/">Prolog</a> programming language</p>
      <p><a href="https://racket-lang.org/">Racket</a> programming language</p>
    </td>
    <td><p>pattern matching for destructuring</p></td>
  </tr>
</table>

This should eliminate skepticism that most of Macroni’s more impressive or unusual features can work.
